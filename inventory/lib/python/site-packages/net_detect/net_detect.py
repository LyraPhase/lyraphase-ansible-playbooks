# -*- Mode: Python; py-indent-offset: 4 -*-
# vim: tabstop=4 shiftwidth=4 expandtab
#
# Copyright (C) 2016-2030 James Cuzella <@trinitronx>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
# USA

# Source: http://stackoverflow.com/questions/166506/finding-local-ip-addresses-using-pythons-stdlib

# imports
import errno
import socket

# localhost prefixes
_local_networks = ("127.", "0:0:0:0:0:0:0:1")

# ignore these prefixes -- localhost, unspecified, and link-local
_ignored_networks = _local_networks + ("0.", "0:0:0:0:0:0:0:0", "169.254.", "fe80:")

# IPv4 / IPv6 Private-Use / Local LAN Addresses
# Reference: http://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
#            http://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml
#            http://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml
#            http://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml
#            https://en.wikipedia.org/wiki/Private_network
#            https://tyler.anairo.com/ipv6-addresses
#            https://en.wikipedia.org/wiki/Link-local_address

_ipv4_private_lan_networks = ("10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16")
_ipv6_private_lan_networks = ("fd00::/8") # ignored "Link-local" fe80::/10 for now...

def detect_family(addr):
    if "." in addr:
        assert ":" not in addr
        return socket.AF_INET
    elif ":" in addr:
        return socket.AF_INET6
    else:
        raise ValueError("invalid ipv4/6 address: %r" % addr)

def expand_addr(addr):
    """convert address into canonical expanded form --
    no leading zeroes in groups, and for ipv6: lowercase hex, no collapsed groups.
    """
    family = detect_family(addr)
    addr = socket.inet_ntop(family, socket.inet_pton(family, addr))
    if "::" in addr:
        count = 8-addr.count(":")
        addr = addr.replace("::", (":0" * count) + ":")
        if addr.startswith(":"):
            addr = "0" + addr
    return addr

def _get_local_addr(family, remote):
    try:
        s = socket.socket(family, socket.SOCK_DGRAM)
        try:
            s.connect((remote, 9))
            return s.getsockname()[0]
        finally:
            s.close()
    except socket.error:
        return None

def get_local_addr(remote=None, ipv6=True):
    """get LAN address of host

    :param remote:
        return  LAN address that host would use to access that specific remote address.
        by default, returns address it would use to access the public internet.

    :param ipv6:
        by default, attempts to find an ipv6 address first.
        if set to False, only checks ipv4.

    :returns:
        primary LAN address for host, or ``None`` if couldn't be determined.
    """
    if remote:
        family = detect_family(remote)
        local = _get_local_addr(family, remote)
        if not local:
            return None
        if family == socket.AF_INET6:
            # expand zero groups so the startswith() test works.
            local = expand_addr(local)
        if local.startswith(_local_networks):
            # border case where remote addr belongs to host
            return local
    else:
        # NOTE: the two addresses used here are TESTNET addresses,
        #       which should never exist in the real world.
        if ipv6:
            local = _get_local_addr(socket.AF_INET6, "2001:db8::1234")
            # expand zero groups so the startswith() test works.
            if local:
                local = expand_addr(local)
        else:
            local = None
        if not local:
            local = _get_local_addr(socket.AF_INET, "192.0.2.123")
            if not local:
                return None
    if local.startswith(_ignored_networks):
        return None
    return local

def ip_is_private(addr):
    family = detect_family(addr)
    if family == socket.AF_INET:
        for cidr in _ipv4_private_lan_networks:
            if ipaddress.ip_address(expand_addr(addr).decode()) in ipaddress.ip_network(cidr.decode()):
                return True
        return False
    elif family == socket.AF_INET6:
        for cidr in _ipv6_private_lan_networks:
            if ipaddress.ip_address(expand_addr(addr).decode()) in ipaddress.ip_network(cidr.decode()):
                return True
        return False

def ip_private_cidr(addr):
    family = detect_family(addr)
    if family == socket.AF_INET:
        for cidr in _ipv4_private_lan_networks:
            if ipaddress.ip_address(expand_addr(addr).decode()) in ipaddress.ip_network(cidr.decode()):
                return cidr
    elif family == socket.AF_INET6:
        for cidr in _ipv6_private_lan_networks:
            if ipaddress.ip_address(expand_addr(addr).decode()) in ipaddress.ip_network(cidr.decode()):
                return cidr

