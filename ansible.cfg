# config file for ansible -- http://ansibleworks.com/
# ==================================================

# nearly all parameters can be overridden in ansible-playbook
# or with command line flags. ansible will read ~/.ansible.cfg,
# ansible.cfg in the current working directory or
# /etc/ansible/ansible.cfg, whichever it finds first

[defaults]

# some basic default values...

# (pathlist) Comma-separated list of Ansible inventory sources
inventory       = ['/etc/ansible/hosts', 'inventory/hosts']
#library        = /usr/share/ansible
#remote_tmp     = ~/.ansible/tmp  # Deprecated (supposedly a shell module option now but no docs?!)
forks          = 5
poll_interval  = 15
transport      = ssh
remote_port    = 22

# (boolean) Toggle to control the showing of deprecation warnings
deprecation_warnings = True

# (integer) Sets the default verbosity, equivalent to the number of ``-v`` passed in the command line.
verbosity = 0

# (bool) Force 'verbose' option to use stderr instead of stdout
#verbose_to_stderr = False

# (bool) Toggle to control whether failed and unreachable tasks are displayed to STDERR rather than STDOUT.
display_failed_stderr = False

# (bool) Toggle to control displaying 'ok' task/host results in a task.
display_ok_hosts = True

# (bool) Toggle to control displaying markers when running in check mode.
# The markers are C(DRY RUN) at the beginning and ending of playbook execution (when calling C(ansible-playbook --check)) and C(CHECK MODE) as a suffix at every play and task that is run in check mode.
check_mode_markers = False

# (bool) This adds output that shows when a task starts to execute for each host.
show_per_host_start = False

# (bool) When a task fails, display the path to the file containing the failed task and the line number. This information is displayed automatically for every task when running with C(-vv) or greater verbosity.
show_task_path_on_failure = False

# (boolean) Toggle to control showing warnings related to running devel.
devel_warning = True

# (string) By default, Ansible will issue a warning when a duplicate dict key is encountered in YAML.
# These warnings can be silenced by adjusting this setting to False.
duplicate_dict_key = warn

# (string) for the cases in which Ansible needs to return a file within an editor, this chooses the application to use.
editor = vi

# (string) for the cases in which Ansible needs to return output in a pageable fashion, this chooses the application to use.
pager = less

# (boolean) Set this to "False" if you want to avoid host key checking by the underlying connection plugin Ansible uses to connect to the host.
# Please read the documentation of the specific connection plugin used for details.
# uncomment this to disable SSH key host checking
host_key_checking = False

# SSH timeout
# (integer) This is the default timeout for connection plugins to use.
timeout = 60

# (integer) Set the maximum time (in seconds) for a task action to execute in.
# Timeout runs independently from templating or looping. It applies per each attempt of executing the task's action and remains unchanged by the total time spent on a task.
# When the action execution exceeds the timeout, Ansible interrupts the process. This is registered as a failure due to outside circumstances, not a task failure, to receive appropriate response and recovery process.
# If set to 0 (the default) there is no timeout.
#task_timeout = 0

# (boolean) Toggles the use of persistence for connections.
#use_persistent_connections = False

# (boolean) Toggle Ansible's display and logging of task details, mainly used to avoid security disclosures.
#no_log = False

# (boolean) Toggles debug output in Ansible. This is *very* verbose and can hinder multiprocessing. Debug output can also include secret information despite no_log settings being enabled, which means debug mode should not be used in production.
#debug = False

# (boolean) Whether or not to enable the task debugger, this previously was done as a strategy plugin.
# Now all strategy plugins can inherit this behavior. The debugger defaults to activating when
# a task is failed on unreachable. Use the debugger keyword for more flexibility.
#enable_task_debugger = False

# (boolean) This option defines whether the task debugger will be invoked on a failed task when ignore_errors=True is specified.
# True specifies that the debugger will honor ignore_errors, and False will not honor ignore_errors.
#task_debugger_ignore_errors = True

# (boolean) Enables/disables the cleaning up of the temporary files Ansible used to execute the tasks on the remote.
# If this option is enabled it will disable ``ANSIBLE_PIPELINING``.
#keep_remote_files = False

# (boolean) Controls whether callback plugins are loaded when running /usr/bin/ansible. This may be used to log activity from the command line, send notifications, and so on. Callback plugins are always loaded for ``ansible-playbook``.
#bin_ansible_callbacks = False

# (string) Set the main callback used to display Ansible output. You can only have one at a time.
# You can have many other callbacks, but just one can be in charge of stdout.
# See :ref:`callback_plugins` for a list of available options.
#stdout_callback = default

# (bool) Configure the result format to be more readable.
# When O(result_format) is set to V(yaml) this option defaults to V(true), and defaults to V(false) when configured to V(json).
# Setting this option to V(true) will force V(json) and V(yaml) results to always be pretty printed regardless of verbosity.
# When set to V(true) and used with the V(yaml) result format, this option will modify module responses in an attempt to produce a more human friendly output at the expense of correctness, and should not be relied upon to aid in writing variable manipulations or conditionals. For correctness, set this option to V(false) or set O(result_format) to V(json).
#callback_format_pretty =

# (str) Define the task result format used in the callback output.
# These formats do not cause the callback to emit valid JSON or YAML formats.
# The output contains these formats interspersed with other non-machine parsable data.
#callback_result_format = json

# (int) Allows to configure indentation for YAML and verbose/pretty JSON.
# Please note that for O(result_format=yaml), only values between 2 and 9 will be handled as expected by PyYAML. If indentation is set to 1, or to 10 or larger, the first level of indentation will be used, but all further indentations will be by 2 spaces.
#callback_result_indentation = 4


# (boolean) Toggle the use of "su" for tasks.
#su = False

# (list) list of users to be expected to have admin privileges. This is used by the controller to determine how to share temporary files between the remote user and the become user.
#admin_users = root, toor

# (string) Checked when Ansible needs to execute a module as a different user.
# If setfacl and chown both fail and do not let the different user access the module's files, they will be chgrp'd to this group.
# In order for this to work, the remote_user and become_user must share a common group and this setting must be set to that group.
#common_remote_group =

# (string) Sets the login user for the target machines
# When blank it uses the connection plugin's default, normally the user currently executing Ansible.
# default user to use for playbooks if user is not specified
# (/usr/bin/ansible will use current user as default)
#remote_user = root
#
# (boolean) This controls whether an Ansible playbook should prompt for a login password. If using SSH keys for authentication, you probably do not need to change this setting.
#ask_pass = False

# (boolean) This controls whether an Ansible playbook should prompt for a vault password.
#ask_vault_pass = False

# (string) The vault_id to use for encrypting by default. If multiple vault_ids are provided, this specifies which to use for encryption. The ``--encrypt-vault-id`` CLI option overrides the configured value.
#vault_encrypt_identity =

# (string) The label to use for the default vault id label in cases where a vault id label is not provided.
#vault_identity = default

# (list) A list of vault-ids to use by default. Equivalent to multiple ``--vault-id`` args. Vault-ids are tried in order.
#vault_identity_list =

# (string) If true, decrypting vaults with a vault id will only try the password from the matching vault-id.
#vault_id_match = False

# (path) The vault password file to use. Equivalent to ``--vault-password-file`` or ``--vault-id``.
# If executable, it will be run and the resulting stdout will be used as the password.
#vault_password_file =

# (string) The salt to use for the vault encryption. If it is not provided, a random salt will be used.
#vault_encrypt_salt =

# (boolean) This option controls if notified handlers run on a host even if a failure occurs on that host.
# When false, the handlers will not run if a failure has occurred on a host.
# This can also be set per play or on the command line. See Handlers and Failure for more details.
#force_handlers = False

# (boolean) Toggle to allow missing handlers to become a warning instead of an error when notifying.
#error_on_missing_handler = True

# (string) This setting controls the default policy of fact gathering (facts discovered about remote systems).
# This option can be useful for those wishing to save fact gathering time. Both 'smart' and 'explicit' will use the cache plugin.
#gathering = implicit

# (list) Which modules to run during a play's fact gathering stage, using the default of 'smart' will try to figure it out based on connection type.
# If adding your own modules but you still want to use the default Ansible facts, you will want to include 'setup' or corresponding network module to the list (if you add 'smart', Ansible will also figure it out).
# This does not affect explicit calls to the 'setup' module, but does always affect the 'gather_facts' action (implicit or explicit).
#facts_modules = smart

# (boolean) Facts are available inside the `ansible_facts` variable, this setting also pushes them as their own vars in the main namespace.
# Unlike inside the `ansible_facts` dictionary where the prefix `ansible_` is removed from fact names, these will have the exact names that are returned by the module.
#inject_facts_as_vars = True

# (str) This setting can be used to optimize vars_plugin usage depending on the user's inventory size and play selection.
#run_vars_plugins = demand

# (list) Accept list for variable plugins that require it.
#vars_plugins_enabled = host_group_vars

# (list) Allows to change the group variable precedence merge order.
#precedence = all_inventory, groups_inventory, all_plugins_inventory, all_plugins_play, groups_plugins_inventory, groups_plugins_play


# (boolean) When True, this causes ansible templating to fail steps that reference variable names that are likely typoed.
# Otherwise, any '{{ template_expression }}' that contains undefined variables will be rendered in a template or ansible action line exactly as written.
#error_on_undefined_vars = True

# (float) This sets the interval (in seconds) of Ansible internal processes polling each other. Lower values improve performance with large playbooks at the expense of extra CPU load. Higher values are more suitable for Ansible usage in automation scenarios when UI responsiveness is not required but CPU usage might be a concern.
# The default corresponds to the value hardcoded in Ansible <= 2.1
#internal_poll_interval=0.001

# (string) Set the default strategy used for plays.
#strategy = linear

# (path) File to which Ansible will log on the controller.
# When not set the logging is disabled.
# logging is off by default unless this path is defined
# if so defined, consider logrotate
#log_path = /var/log/ansible.log

# (int) This will set log verbosity if higher than the normal display verbosity, otherwise it will match that.
#log_verbosity =

# (list) List of logger names to filter out of the log file.
#log_filter =

# (boolean) Toggle Ansible logging to syslog on the target when it executes tasks. On Windows hosts, this will disable a newer style PowerShell modules from writing to the event log.
#no_target_syslog = False

# (string) Syslog facility to use when Ansible logs to the remote target.
#syslog_facility = LOG_USER

# (string) A string to insert into target logging for tracking purposes
#target_log_info=

# (boolean) Normally ``ansible-playbook`` will print a header for each task that is run. These headers will contain the name: field from the task if you specified one. If you didn't then ``ansible-playbook`` uses the task's action to help you tell which task is presently running. Sometimes you run many of the same action and so you want more information about the task to differentiate it from others of the same action. If you set this variable to True in the config then ``ansible-playbook`` will also include the task's arguments in the header.
# This setting defaults to False because there is a chance that you have sensitive values in your parameters and you do not want those to be printed.
# If you set this to True you should be sure that you have secured your environment's stdout (no one can shoulder surf your screen and you aren't saving stdout to an insecure file) or made sure that all of your playbooks explicitly added the ``no_log: True`` parameter to tasks that have sensitive values :ref:`keep_secret_data` for more information.
#display_args_to_stdout = False

# (bool) This adds the custom stats set via the set_stats plugin to the default output.
#show_custom_stats = False

# (int) Maximum size of files to be considered for diff display.
#max_diff_size = 104448

# (boolean) Toggle to control displaying skipped task/host entries in a task in the default callback.
#display_skipped_hosts = True

# (list) When to include tracebacks in extended error messages
#display_traceback = never

# (string) Root docsite URL used to generate docs URLs in warning/error text; must be an absolute URL with a valid scheme and trailing slash.
#docsite_root_url = https://docs.ansible.com/ansible-core/

# (string) Compression scheme to use when transferring Python modules to the target.
#module_compression = ZIP_DEFLATED

# (string) Module to use with the ``ansible`` AdHoc command, if none is specified via ``-m``.
# default module name for /usr/bin/ansible
#module_name = command

# (string) This sets the default arguments to pass to the ``ansible`` adhoc binary if no ``-a`` is specified.
#module_args =

# (list) List of extensions to ignore when looking for modules to load.
# This is for rejecting script and binary module fallback extensions.
#module_ignore_exts = .pyc, .pyo, .swp, .bak, ~, .rpm, .md, .txt, .rst, .yaml, .yml, .ini

# (bool) Enables whether module responses are evaluated for containing non-UTF-8 data.
# Disabling this may result in unexpected behavior.
# Only ansible-core should evaluate this configuration.
#module_strict_utf8_response = True

# (list) TODO: write it
#network_group_modules = eos, nxos, ios, iosxr, junos, enos, ce, vyos, sros, dellos9, dellos10, dellos6, asa, aruba, aireos, bigip, ironware, onyx, netconf, exos, voss, slxos

# (string) This indicates the command to use to spawn a shell under, which is required for Ansible's execution needs on a target. Users may need to change this in rare instances when shell usage is constrained, but in most cases, it may be left as is.
# use this shell for commands executed under sudo
# you may need to change this to bin/bash in rare instances
# if sudo is constrained
#executable = /bin/sh

# (string) Path to the Python interpreter to be used for module execution on remote targets, or an automatic discovery mode. Supported discovery modes are ``auto`` (the default), ``auto_silent``, ``auto_legacy``, and ``auto_legacy_silent``. All discovery modes match against an ordered list of well-known Python interpreter locations. The fallback behavior will issue a warning that the interpreter should be set explicitly (since interpreters installed later may change which one is used). This warning behavior can be disabled by setting ``auto_silent``. The ``auto_legacy`` modes are deprecated and behave the same as their respective ``auto`` modes. They exist for backward-compatibility with older Ansible releases that always defaulted to ``/usr/bin/python3``, which will use that interpreter if present.
#interpreter_python = auto

# if inventory variables overlap, does the higher precedence one win
# or are hash values merged together?  The default is 'replace' but
# this can also be set to 'merge'.
#hash_behaviour = replace

# How to handle variable replacement - as of 1.2, Jinja2 variable syntax is
# preferred, but we still support the old $variable replacement too.
# Turn off ${old_style} variables here if you like.
#legacy_playbook_variables = yes

# (list) This is a developer-specific feature that allows enabling additional Jinja2 extensions.
# See the Jinja2 documentation for details. If you do not know what these do, you probably don't need to change this setting :)
# list any Jinja2 extensions to enable here:
#jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n

# (boolean) This option preserves variable types during template operations.
#jinja2_native=True

# (raw) What templating should return as a 'null' value. When not set it will let Jinja2 decide.
#null_representation=

# (list) Check all of these extensions when looking for 'variable' files which should be YAML or JSON or vaulted versions of these.
# This affects vars_files, include_vars, inventory and vars plugins among others.
#yaml_valid_extensions = .yml, .yaml, .json

# (path) Option for connections using a certificate or key file to authenticate, rather than an agent or passwords, you can set the default value here to avoid re-specifying ``--private-key`` with every invocation.
# if set, always use this private key file for authentication, same as
# if passing --private-key to ansible or ansible-playbook
#private_key_file = /path/to/file

# (string) Sets the macro for the 'ansible_managed' variable available for :ref:`ansible_collections.ansible.builtin.template_module` and :ref:`ansible_collections.ansible.windows.win_template_module`.  This is only relevant to those two modules.
# format of string {{ ansible_managed }} available within Jinja2
# templates indicates to users editing templates files will be replaced.
# replacing {file}, {host} and {uid} and strftime codes with proper values.
ansible_managed = Ansible managed: {file}

# by default (as of 1.3), Ansible will raise errors when attempting to dereference
# Jinja2 variables that are not set in templates or action lines. Uncomment this line
# to revert the behavior to pre-1.3.
#error_on_undefined_vars = False

# (boolean) If 'false', invalid attributes for a task will result in warnings instead of errors.
#invalid_task_attribute_failed = True

# (boolean) Allows disabling of warnings related to potential issues on the system running Ansible itself (not on the managed hosts).
# These may include warnings about third-party packages or other conditions that should be resolved if possible.
#system_warnings = True

# (boolean) By default, Ansible will issue a warning when there are no hosts in the inventory.
# These warnings can be silenced by adjusting this setting to False.
#localhost_warning = True

# set plugin path directories here, seperate with colons
action_plugins     = /usr/share/ansible_plugins/action_plugins
callback_plugins   = /usr/share/ansible_plugins/callback_plugins
connection_plugins = /usr/share/ansible_plugins/connection_plugins
lookup_plugins     = /usr/share/ansible_plugins/lookup_plugins
vars_plugins       = /usr/share/ansible_plugins/vars_plugins
filter_plugins     = /usr/share/ansible_plugins/filter_plugins

# set modules paths here, separate with colons
collections_path   = ./collections:/usr/share/ansible/collections
roles_path         = /usr/share/ansible/roles:/etc/ansible/roles

# (path) A number of non-playbook CLIs have a ``--playbook-dir`` argument; this sets the default value for it.
#playbook_dir =

# (string) This sets which playbook dirs will be used as a root to process vars plugins, which includes finding host_vars/group_vars.
#playbook_vars_root = top

# (string) Make ansible transform invalid characters in group names supplied by inventory sources.
#force_valid_group_names = never

# (bool) A toggle to disable validating a collection's 'metadata' entry for a module_defaults action group. Metadata containing unexpected fields or value types will produce a warning when this is True.
#validate_action_group_metadata = True

# (bool) This controls whether a failed Ansible playbook should create a .retry file.
#retry_files_enabled = False

# (path) This sets the path in which Ansible will save .retry files when a playbook fails and retry files are enabled.
# This file will be overwritten after each run with the list of failed hosts from all plays.
#retry_files_save_path =

# (boolean) Previously Ansible would only clear some of the plugin loading caches when loading new roles, this led to some behaviors in which a plugin loaded in previous plays would be unexpectedly 'sticky'. This setting allows the user to return to that behavior.
#old_plugin_cache_clear = False

# (path) A path to configuration for filtering which plugins installed on the system are allowed to be used.
# See :ref:`plugin_filtering_config` for details of the filter file's format.
#  The default is /etc/ansible/plugin_filters.yml
#plugin_filters_cfg =

# (string) Attempts to set RLIMIT_NOFILE soft limit to the specified value when executing Python modules (can speed up subprocess usage on Python 2.x. See https://bugs.python.org/issue11284). The value will be limited by the existing hard limit. Default value of 0 does not attempt to adjust existing system-defined limits.
#python_module_rlimit_nofile = 0

# (list) List of valid system temporary directories on the managed machine for Ansible to validate O(remote_tmp) against, when specific permissions are needed. These must be world readable, writable, and executable. This list should only contain directories which the system administrator has pre-created with the proper ownership and permissions otherwise security issues can arise.
# When O(remote_tmp) is required to be a system temp dir and it does not match any in the list, the first one from the list will be used instead.
#system_tmpdirs = /var/tmp, /tmp

# (string) Directory in which ansible will keep async job information.
#async_dir = ~/.ansible_async

# (boolean) This makes the temporary files created on the machine world-readable and will issue a warning instead of failing the task.
# It is useful when becoming an unprivileged user.
#allow_world_readable_tmpfiles = False

# (integer) For asynchronous tasks in Ansible (covered in Asynchronous Actions and Polling), this is how long, in seconds, to wait for the task spawned by Ansible to connect back to the named pipe used on Windows systems. The default is 5 seconds. This can be too low on slower systems, or systems under heavy load.
# This is not the total time an async command can run for, but is a separate timeout to wait for an async command to start. The task will only start to be timed against its async_timeout once it has connected to the pipe, so the overall maximum duration the task can take will be extended by the amount specified here.
#win_async_startup_timeout = 5


# don't like cows?  that's unfortunate.
# set to 1 if you don't want cowsay support or export ANSIBLE_NOCOWS=1
#nocows = 1

# don't like colors either?
# set to 1 if you don't want colors, or export ANSIBLE_NOCOLOR=1
#nocolor = 1

# (boolean) By default, imported roles publish their variables to the play and other roles, this setting can avoid that.
# This was introduced as a way to reset role variables to default values if a role is used more than once in a playbook.
# Starting in version '2.17' M(ansible.builtin.include_roles) and M(ansible.builtin.import_roles) can individually override this via the C(public) parameter.
# Included roles only make their variables public at execution, unlike imported roles which happen at playbook compile time.
#private_role_vars = False

[privilege_escalation]
# (boolean) Toggles the use of privilege escalation, allowing you to 'become' another user after login.
become = False

# (boolean) Toggle to prompt for privilege escalation password.
#become_ask_pass = False

# (string) The user your login/remote user 'becomes' when using privilege escalation, most systems will use 'root' when no user is specified.
become_user = root

# (string) Privilege escalation method to use when `become` is enabled.
become_method = sudo

# (string) executable to use for privilege escalation, otherwise Ansible will depend on PATH.
# change this for alternative sudo implementations
#become_exe = sudo

# (string) Flags to pass to the privilege escalation executable.
# what flags to pass to sudo
become_flags = -H

# (boolean) Display an agnostic become prompt instead of displaying a prompt containing the command line supplied become method.
#agnostic_become_prompt = True

# (boolean) When ``False``(default), Ansible will skip using become if the remote user is the same as the become user, as this is normally a redundant operation. In other words root sudo to root.
# If ``True``, this forces Ansible to use the become plugin anyways as there are cases in which this is needed.
#become_allow_same_user = False


[persistent_connection]
# (path) Specify where to look for the ansible-connection script. This location will be checked before searching $PATH.
# If null, ansible will start with the same directory as the ansible script.
#ansible_connection_path =

# (int) This controls the amount of time to wait for a response from a remote device before timing out a persistent connection.
command_timeout = 30

# (integer) This controls the retry timeout for persistent connection to connect to the local domain socket.
connect_retry_timeout = 15

# (integer) This controls how long the persistent connection will remain idle before it is destroyed.
connect_timeout = 30

# (path) Path to the socket to be used by the connection persistence system.
#control_path_dir = ~/.ansible/pc


[connection]
# (boolean) This is a global option, each connection plugin can override either by having more specific options or not supporting pipelining at all.
# Pipelining, if supported by the connection plugin, reduces the number of network operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfer.
# It can result in a very significant performance improvement when enabled.
# However this conflicts with privilege escalation (become). For example, when using 'sudo:' operations you must first disable 'requiretty' in /etc/sudoers on all managed hosts, which is why it is disabled by default.
# This setting will be disabled if ``ANSIBLE_KEEP_REMOTE_FILES`` is enabled.
#pipelining = False # (default)
pipelining = True

# (string) Manage an SSH Agent via Ansible. A configuration of ``none`` will not interact with an agent, ``auto`` will start and destroy an agent via ``ssh-agent`` binary during the run, and a path to an SSH_AUTH_SOCK will allow interaction with a pre-existing agent.
#ssh_agent = none

# (str) When ``SSH_AGENT`` is ``auto``, the path or name of the ssh agent executable to start.
#ssh_agent_executable = ssh-agent # (default)
#ssh_agent_executable = gpg-agent

# (int) For keys inserted into an agent defined by ``SSH_AGENT``, define a lifetime, in seconds, that the key may remain in the agent.
#ssh_agent_key_lifetime =


[colors]
# 256 ANSI Color Support
# Reference: https://github.com/ansible/ansible/pull/17752/files
# Spec:
#   - colorNNN: color(?P<color>[0-9]+)
#   - rgbXYZ: (?P<rgb>rgb(?P<red>[0-5])(?P<green>[0-5])(?P<blue>[0-5]))
#     - X: Red number value (16 + 36 * X)
#     - Y: Green number value (6 * Y)
#     - Z: Blue number value (Z)
#   - grayNNN: gray(?P<gray>[0-9]+)
#     - 232 + gray number 'NNN'

# (string) Defines the color to use on 'Changed' task status.
#changed = yellow

# (string) Defines the default color to use for ansible-console.
#console_prompt = white

# (string) Defines the color to use when emitting debug messages.
#debug = dark gray # (default)
debug = gray14

# (string) Defines the color to use when emitting deprecation messages.
#deprecate = purple

# (string) Defines the color to use when showing added lines in diffs.
#diff_add = green

# (string) Defines the color to use when showing diffs.
#diff_lines = cyan

# (string) Defines the color to use when showing removed lines in diffs.
#diff_remove = red

# (string) Defines the color to use when emitting a constant in the ansible-doc output.
#doc_constant = dark gray

# (string) Defines the color to use when emitting a deprecated value in the ansible-doc output.
#doc_deprecated = magenta

# (string) Defines the color to use when emitting a link in the ansible-doc output.
#doc_link = cyan

# (string) Defines the color to use when emitting a module name in the ansible-doc output.
#doc_module = yellow

# (string) Defines the color to use when emitting a plugin name in the ansible-doc output.
#doc_plugin = yellow

# (string) Defines the color to use when emitting cross-reference in the ansible-doc output.
#doc_reference = magenta

# (string) Defines the color to use when emitting error messages.
#error = red
error = color160

# (string) Defines the color to use for highlighting.
#highlight = white

# (string) Defines the color to use when showing 'Included' task status.
#included = cyan

# (string) Defines the color to use when showing 'OK' task status.
#ok = green

# (string) Defines the color to use when showing 'Skipped' task status.
#skip = cyan

# (string) Defines the color to use on 'Unreachable' status.
#unreachable = bright red

# (string) Defines the color to use when emitting verbose messages. In other words, those that show with '-v's.
#verbose = blue

# (string) Defines the color to use when emitting warning messages.
#warn = bright purple


[selinux]
# (boolean) This setting causes libvirt to connect to LXC containers by passing ``--noseclabel`` parameter to ``virsh`` command. This is necessary when running on systems which do not have SELinux.
#libvirt_lxc_noseclabel = False

# (list) Some filesystems do not support safe operations and/or return inconsistent errors, this setting makes Ansible 'tolerate' those in the list without causing fatal errors.
# Data corruption may occur and writes are not always verified when a filesystem is in the list.
#special_context_filesystems = fuse, nfs, vboxsf, ramfs, 9p, vfat


[diff]
# (bool) Configuration toggle to tell modules to show differences when in 'changed' status, equivalent to ``--diff``.
#always = False

# (integer) Number of lines of context to show when displaying the differences between files.
#context = 3


[galaxy]
# (path) The directory that stores cached responses from a Galaxy server.
# This is only used by the ``ansible-galaxy collection install`` and ``download`` commands.
# Cache files inside this dir will be ignored if they are world writable.
#cache_dir = ~/.ansible/galaxy_cache

# (bool) whether ``ansible-galaxy collection install`` should warn about ``--collections-path`` missing from configured :ref:`collections_paths`.
#collections_path_warning = True

# (path) Collection skeleton directory to use as a template for the ``init`` action in ``ansible-galaxy collection``, same as ``--collection-skeleton``.
#collection_skeleton =

# (list) patterns of files to ignore inside a Galaxy collection skeleton directory.
#collection_skeleton_ignore = ^.git$, ^.*/.git_keep$

# (bool) Disable GPG signature verification during collection installation.
#disable_gpg_verify = False

# (bool) Some steps in ``ansible-galaxy`` display a progress wheel which can cause issues on certain displays or when outputting the stdout to a file.
# This config option controls whether the display wheel is shown or not.
# The default is to show the display wheel if stdout has a tty.
#display_progress =

# (path) Configure the keyring used for GPG signature verification during collection installation and verification.
#gpg_keyring =

# (boolean) If set to yes, ansible-galaxy will not validate TLS certificates. This can be useful for testing against a server with a self-signed certificate.
#ignore_certs =

# (list) A list of GPG status codes to ignore during GPG signature verification. See L(https://github.com/gpg/gnupg/blob/master/doc/DETAILS#general-status-codes) for status code descriptions.
# If fewer signatures successfully verify the collection than `GALAXY_REQUIRED_VALID_SIGNATURE_COUNT`, signature verification will fail even if all error codes are ignored.
#ignore_signature_status_codes =

# (str) The number of signatures that must be successful during GPG signature verification while installing or verifying collections.
# This should be a positive integer or all to indicate all signatures must successfully validate the collection.
# Prepend + to the value to fail if no valid signatures are found for the collection.
#required_valid_signature_count = 1

# (path) Role skeleton directory to use as a template for the ``init`` action in ``ansible-galaxy``/``ansible-galaxy role``, same as ``--role-skeleton``.
#role_skeleton =

# (list) patterns of files to ignore inside a Galaxy role or collection skeleton directory.
#role_skeleton_ignore = ^.git$, ^.*/.git_keep$

# (string) URL to prepend when roles don't specify the full URI, assume they are referencing this server as the source.
#server = https://galaxy.ansible.com

# (list) A list of Galaxy servers to use when installing a collection.
# The value corresponds to the config ini header ``[galaxy_server.{{item}}]`` which defines the server details.
# See :ref:`galaxy_server_config` for more details on how to define a Galaxy server.
# The order of servers in this list is used as the order in which a collection is resolved.
# Setting this config option will ignore the :ref:`galaxy_server` config option.
#server_list =

# (int) The default timeout for Galaxy API calls. Galaxy servers that don't configure a specific timeout will fall back to this value.
#server_timeout = 60

# (path) Local path to galaxy access token file
#token_path = ~/.ansible/galaxy_token


[inventory]
# (string) This setting changes the behaviour of mismatched host patterns, it allows you to force a fatal error, a warning or just ignore it.
#host_pattern_mismatch = warning

# (boolean) If 'true', it is a fatal error when any given inventory source cannot be successfully parsed by any available inventory plugin; otherwise, this situation only attracts a warning.

#any_unparsed_is_failed = False

# (list) List of enabled inventory plugins, it also determines the order in which they are used.
#enable_plugins = host_list, script, auto, yaml, ini, toml

# (bool) Controls if ansible-inventory will accurately reflect Ansible's view into inventory or its optimized for exporting.
#export = False

# (list) List of extensions to ignore when using a directory as an inventory source.
#ignore_extensions = .pyc, .pyo, .swp, .bak, ~, .rpm, .md, .txt, .rst, .orig, .cfg, .retry

# (list) List of patterns to ignore when using a directory as an inventory source.
#ignore_patterns =

# (bool) If 'true' it is a fatal error if every single potential inventory source fails to parse, otherwise, this situation will only attract a warning.

#unparsed_is_failed = False

# (boolean) By default, Ansible will issue a warning when no inventory was loaded and notes that it will use an implicit localhost-only inventory.
# These warnings can be silenced by adjusting this setting to False.
#inventory_unparsed_warning = True


[netconf_connection]
# (string) This variable is used to enable bastion/jump host with netconf connection. If set to True the bastion/jump host ssh settings should be present in ~/.ssh/config file, alternatively it can be set to custom ssh configuration file path to read the bastion/jump host settings.
#ssh_config =


[jinja2]
# (list) This list of filters avoids 'type conversion' when templating variables.
# Useful when you want to avoid conversion into lists or dictionaries for JSON strings, for example.
#dont_type_filters = string, to_json, to_nice_json, to_yaml, to_nice_yaml, ppretty, json


[tags]
# (list) default list of tags to run in your plays, Skip Tags has precedence.
#run =

# (list) default list of tags to skip in your plays, has precedence over Run Tags
#skip =


#[runas_become_plugin]
# (string) Options to pass to runas, a space delimited list of k=v pairs
#flags =

# (string) password
#password =

# (string) User you 'become' to execute the task
#user =


#[su_become_plugin]
# (string) Su executable
#executable = su

# (string) Options to pass to su
#flags =

# (string) Password to pass to su
#password =

# (string) User you 'become' to execute the task
#user = root

# (list) List of localized strings to match for prompt detection
# If empty we'll use the built in one
# Do NOT add a colon (:) to your custom entries. Ansible adds a colon at the end of each prompt; if you add another one in your string, your prompt will fail with a "Timeout" error.
#localized_prompts =


[sudo_become_plugin]
# (string) Sudo executable
executable = sudo

# (string) Options to pass to sudo
flags = -H -S -n

# (string) Password to pass to sudo
#password =

# (string) User you 'become' to execute the task
#user = root

# (string) Directory to change to before invoking sudo; can avoid permission errors when dropping privileges.
#chdir =


#[callback_tree]
# (path) directory that will contain the per host JSON files. Also set by the C(--tree) option when using adhoc.
#directory = ~/.ansible/tree


#[paramiko_connection]
# (float) Configures, in seconds, the amount of time to wait for the SSH banner to be presented. This option is supported by paramiko version 1.15.0 or newer.
#banner_timeout = 30

# (boolean) Automatically add host keys
#host_key_auto_add =

# (boolean) Set this to "False" if you want to avoid host key checking by the underlying tools Ansible uses to connect to the host
#host_key_checking = True

# (boolean) False to disable searching for private key files in ~/.ssh/
#look_for_keys = True

# (int) Remote port to connect to.
#remote_port = 22

# (string) Path to private key file to use for authentication.
#private_key_file =

# (string) Proxy information for running the connection via a jumphost.
#proxy_command =

# (boolean) SUDO usually requires a PTY, True to give a PTY and False to not give a PTY.
#pty = True

# (boolean) Save the host keys to a file
#record_host_keys = True # (default)
# uncomment this line to cause the paramiko connection plugin to not record new host
# keys encountered.  Increases performance on new host additions.  Setting works independently of the
# host key checking setting above.
#record_host_keys = False

# (string) User to login/authenticate as
# Can be set from the CLI via the C(--user) or C(-u) options.
#remote_user =

# (int) Number of seconds until the plugin gives up on failing to establish a TCP connection.
#timeout = 10

# (boolean) Whether or not to enable RSA SHA2 algorithms for pubkeys and hostkeys
# On paramiko versions older than 2.9, this only affects hostkeys
# For behavior matching paramiko<2.9 set this to V(False)
#use_rsa_sha2_algorithms = True


[ssh_connection]
# (string) This is the location to save SSH's ControlPath sockets, it uses SSH's variable substitution.
# Since 2.3, if null (default), ansible will generate a unique hash. Use ``%(directory)s`` to indicate where to use the control dir path setting.
# Before 2.3 it defaulted to ``control_path=%(directory)s/ansible-ssh-%%h-%%p-%%r``.
# Be aware that this setting is ignored if C(-o ControlPath) is set in ssh args.
# On some systems with very long hostnames or very long path names
# (caused by long user names or deeply nested home directories) this can exceed
# the character limit on file socket names (108 characters for most platforms).
# In that case, you may wish to shorten the string below.
# Example:
# control_path = %(directory)s/%%h-%%r
# control_path = %(directory)s/ansible-ssh-%%h-%%p-%%r
#control_path =

# (string) This sets the directory to use for ssh control path if the control path setting is null.
# Also, provides the ``%(directory)s`` variable for the control path setting.
#control_path_dir = ~/.ansible/cp

# (boolean) Determines if SSH should reject or not a connection after checking host keys.
#host_key_checking = True

# (string) Mechanism to use for handling ssh password prompt
#password_mechanism = ssh_askpass

# (boolean) Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.
# This can result in a very significant performance improvement when enabled.
# However this can conflict with privilege escalation (C(become)). For example, when using sudo operations you must first disable C(requiretty) in the sudoers file for the target hosts, which is why this feature is disabled by default.
#pipelining=False # (default)
pipelining = True

# (string) Arguments to pass to all SSH CLI tools.
#ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s # (default)
# Leaving off ControlPersist will result in poor performance, so use
# paramiko on older platforms rather than removing it
ssh_args = -C -o ForwardAgent=yes -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlMaster=auto -o ControlPersist=60s

# (string) PKCS11 SmartCard provider such as opensc, example: /usr/local/lib/opensc-pkcs11.so
pkcs11_provider =

# (integer) Number of attempts to connect.
# Ansible retries connections only if it gets an SSH error with a return code of 255.
# Any errors with return codes other than 255 indicate an issue with program execution.
retries = 0

# (string) This defines the location of the scp binary. It defaults to V(scp) which will use the first binary available in $PATH.
#scp_executable = scp

# (string) Extra exclusive to the C(scp) CLI
#scp_extra_args =

# (bool) When set to C(True), sftp will be run in batch mode, allowing detection of transfer errors.
# When set to C(False), sftp will not be run in batch mode, preventing detection of transfer errors.
#sftp_batch_mode = True

# (string) This defines the location of the sftp binary. It defaults to V(sftp) which will use the first binary available in $PATH.
#sftp_executable = sftp

# (string) Extra exclusive to the C(sftp) CLI
#sftp_extra_args =

# (string) Common extra args for all SSH CLI tools.
#ssh_common_args =

# (string) This defines the location of the SSH binary. It defaults to V(ssh) which will use the first SSH binary available in $PATH.
# This option is usually not required, it might be useful when access to system SSH is restricted, or when using SSH wrappers to connect to remote hosts.
#ssh_executable = ssh

# (string) Extra exclusive to the SSH CLI.
#ssh_extra_args =

# (string) Preferred method to use when transferring files over ssh
#transfer_method = smart

# (string) Password prompt that C(sshpass)/C(SSH_ASKPASS) should search for.
# Supported by sshpass 1.06 and up when O(password_mechanism) set to V(sshpass).
# Defaults to C(Enter PIN for) when pkcs11_provider is set.
# Defaults to C(assword) when O(password_mechanism) set to V(ssh_askpass).
#sshpass_prompt =

# (integer) This is the default amount of time we will wait while establishing an SSH connection.
# It also controls how long we can wait to access reading the connection once established (select on the socket).
#timeout = 10

# (bool) add -tt to ssh commands to force tty allocation.
#usetty = True

# (int) Requested verbosity level for the SSH CLI.
#verbosity = 0


#[winrm]
# (list) A list of environment variables to pass through to C(kinit) when getting the Kerberos authentication ticket.
# By default no environment variables are passed through and C(kinit) is run with a blank slate.
# The environment variable C(KRB5CCNAME) cannot be specified here as it's used to store the temp Kerberos ticket used by WinRM.
#kinit_env_vars =


#[inventory_plugins]
# (bool) Merge extra vars into the available variables for composition (highest precedence).
#use_extra_vars = False


#[inventory_plugin_script]
# (boolean) Toggle display of stderr even when script was successful
#always_show_stderr = True


#[inventory_plugin_yaml]
# (list) list of 'valid' extensions for files containing YAML
#yaml_valid_extensions = .yaml, .yml, .json


#[url_lookup]
# (string) String of file system path to CA cert bundle to use
#ca_path =

# (list) SSL/TLS Ciphers to use for the request
# When a list is provided, all ciphers are joined in order with C(:)
# See the L(OpenSSL Cipher List Format,https://docs.openssl.org/master/man1/openssl-ciphers/#cipher-list-format) for more details.
# The available ciphers is dependent on the Python and OpenSSL/LibreSSL versions
#ciphers =

# (string) Whether or not the URI module should follow redirects.
#follow_redirects = urllib2

# (boolean) Whether or not to set "cache-control" header with value "no-cache"
#force = False

# (boolean) Force basic authentication
#force_basic_auth = False

# (string) User-Agent to use in the request. The default was changed in 2.11 to V(ansible-httpget).
#agent = ansible-httpget

# (float) How long to wait for the server to send data before giving up
#timeout = 10

# (string) String of file system path to unix socket file to use when establishing connection to the provided url
#unix_socket =

# (list) A list of headers to not attach on a redirected request
#unredirected_headers =

# (boolean) Use GSSAPI handler of requests
# As of Ansible 2.11, GSSAPI credentials can be specified with O(username) and O(password).
#use_gssapi = False

# (boolean) Determining whether to use credentials from ``~/.netrc`` file
# By default .netrc is used with Basic authentication headers
# When set to False, .netrc credentials are ignored
#use_netrc=True


#[powershell]
# (string) Directory in which ansible will keep async job information.
# Before Ansible 2.8, this was set to C(remote_tmp + "\.ansible_async").
#async_dir=%USERPROFILE%\.ansible_async

# (string) Temporary directory to use on targets when copying files to the host.
#remote_tmp=%TEMP%


#[vars_host_group_vars]
# (str) Control when this vars plugin may be executed.
# Setting this option to V(all) will run the vars plugin after importing inventory and whenever it is demanded by a task.
# Setting this option to V(task) will only run the vars plugin whenever it is demanded by a task.
# Setting this option to V(inventory) will only run the vars plugin after parsing inventory.
# If this option is omitted, the global C(RUN_VARS_PLUGINS) configuration is used to determine when to execute the vars plugin.
#stage=




## OLD / DEPRECATED

#[accelerate]
#accelerate_port = 5099
